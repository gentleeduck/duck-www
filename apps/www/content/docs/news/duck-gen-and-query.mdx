---
title: duck gen and duck query
description: Type-safe API generation and HTTP client for TypeScript. Scan your server code, emit .d.ts files, and get fully typed requests and responses with zero runtime cost.
---

<Image
  src="https://github.com/gentleeduck/duck-ui/blob/master/apps/duck-gen-docs/public/og/root.png?raw=true"
  alt="Duck Gen documentation"
  width="1200"
  height="630"
  className="w-full rounded-lg border shadow-sm"
/>

## The Problem

Every team that builds a TypeScript client and server hits the same wall: **keeping types in sync**.

You add a route on the server. You update the DTO. Then you go to the client and manually write matching types. Maybe you forget. Maybe the types drift. Maybe someone changes a field name and the client silently breaks.

```ts
// Server: you add a new route
@Post('signup')
signup(@Body() body: SignupDto): Promise<AuthSession> { ... }

// Client: you manually write the matching types... or forget to
type SignupReq = { email: string; password: string }  // hope this matches SignupDto
type SignupRes = { token: string }                     // hope this matches AuthSession
```

Duck Gen and Duck Query exist to eliminate this entire category of bugs.

---

## Duck Gen -- The Compiler Extension

Duck Gen is a **compiler extension** that reads your server source code and generates TypeScript definition files (`.d.ts`) describing every API route and message key it finds.

Instead of writing route types by hand, Duck Gen automates the entire contract layer.

### What it generates

| Category | Output |
| --- | --- |
| **API route types** | A route map with typed request shapes (body, query, params, headers) and response types for every controller method. |
| **Message registry types** | Strongly-typed i18n dictionaries derived from `@duckgen` message tags in your code. |

Both outputs are `.d.ts` files you import directly -- no runtime cost, just types.

### How it works

<MermaidDiagram chart={`flowchart TD
    A["duck-gen.json config"] -->|framework + paths| B["ts-morph project"]
    B --> C{"Scan source files"}
    C -->|"@Controller classes"| D["Route Extractor"]
    C -->|"@duckgen JSDoc tags"| E["Message Extractor"]
    D --> F["Extract HTTP method + path"]
    D --> G["Extract DTOs + response types"]
    F --> H["api-routes.d.ts"]
    G --> H
    E --> I["messages.d.ts"]
    style A fill:#f9f,stroke:#333
    style H fill:#9f9,stroke:#333
    style I fill:#9f9,stroke:#333`} />

Duck Gen uses [ts-morph](https://ts-morph.com/) to parse your source files statically. It finds every `@Controller` class, extracts the HTTP method decorators (`@Get`, `@Post`, `@Put`, `@Delete`, `@Patch`), resolves the full route path, and reads the parameter decorators (`@Body`, `@Query`, `@Param`, `@Headers`) to determine request shapes. Response types come from the method's return type.

The result is a complete route map that looks like this:

```ts
// Generated by duck-gen -- do not edit
export interface ApiRoutes {
  '/api/auth/signin': {
    POST: {
      body: SigninDto
      res: AuthSession
    }
  }
  '/api/auth/signup': {
    POST: {
      body: SignupDto
      res: AuthSession
    }
  }
  '/api/users/:id': {
    GET: {
      params: { id: string }
      res: UserProfile
    }
    PATCH: {
      params: { id: string }
      body: UpdateUserDto
      res: UserProfile
    }
  }
}
```

### Configuration

Duck Gen reads a `duck-gen.json` file in your project root:

```json
{
  "framework": "nestjs",
  "srcDir": "./src",
  "outputDir": "./generated",
  "apiPrefix": "/api",
  "include": ["**/*.controller.ts"],
  "exclude": ["**/*.spec.ts"]
}
```

One command generates everything:

```bash
bunx @gentleduck/gen
```

---

## Duck Query -- The Type-Safe Client

Duck Query is a **type-safe HTTP client** built on [Axios](https://axios-http.com/). It takes the route map generated by Duck Gen and gives you a client where every request path, body, query parameter, and response is **type-checked at compile time**.

### Before and after

**Before (manual types, no safety):**

```ts
const res = await axios.post('/api/auth/signin', {
  emial: 'test@example.com',  // typo -- no error
  password: '123',
})
// res.data is `any` -- no type checking
```

**After (Duck Query + Duck Gen):**

```ts
const res = await client.post('/api/auth/signin', {
  emial: 'test@example.com',  // TypeScript error: 'emial' does not exist on SigninDto
  password: '123',
})
// res.data is AuthSession -- fully typed
```

### The full pipeline

<MermaidDiagram chart={`flowchart LR
    subgraph Server["NestJS Server"]
        A["Controllers + DTOs"]
    end
    subgraph Gen["Duck Gen"]
        B["Scan + Extract"]
        C["Emit .d.ts"]
    end
    subgraph Types["Generated Types"]
        D["ApiRoutes interface"]
    end
    subgraph Client["Duck Query"]
        E["Typed HTTP methods"]
        F["Typed responses"]
    end
    A --> B --> C --> D
    D -->|"generic param"| E --> F
    style A fill:#e8e8ff,stroke:#333
    style D fill:#e8ffe8,stroke:#333
    style F fill:#fff8e8,stroke:#333`} />

### Setup

```ts
import { createDuckQuery } from '@gentleduck/query'
import type { ApiRoutes } from './generated/api-routes'

const client = createDuckQuery<ApiRoutes>({
  baseURL: 'https://api.example.com',
})

// Every method is fully typed
const session = await client.post('/api/auth/signin', {
  body: { email: 'user@example.com', password: 'secret' },
})
// session.data -> AuthSession

const user = await client.get('/api/users/:id', {
  params: { id: '123' },
})
// user.data -> UserProfile
```

---

## Getting Started

<div className="mt-6 grid gap-4 sm:grid-cols-2 sm:gap-6">
  <LinkedCard href="https://gen.gentleduck.org/docs/duck-gen" target="_blank" rel="noopener noreferrer">
    <div className="flex flex-col p-4">
      <h4 className="font-semibold">Duck Gen Docs</h4>
      <p className="mt-2 text-muted-foreground text-sm">Configuration, generated types, API routes, and message registries.</p>
    </div>
  </LinkedCard>
  <LinkedCard href="https://gen.gentleduck.org/docs/duck-query" target="_blank" rel="noopener noreferrer">
    <div className="flex flex-col p-4">
      <h4 className="font-semibold">Duck Query Docs</h4>
      <p className="mt-2 text-muted-foreground text-sm">Client setup, typed methods, advanced usage, and custom route maps.</p>
    </div>
  </LinkedCard>
</div>

### Install

```bash
# Install Duck Gen (dev dependency -- only runs at build time)
bun add -d @gentleduck/gen

# Install Duck Query (runtime dependency)
bun add @gentleduck/query
```

Duck Gen is framework-aware. NestJS is the first supported framework, with more adapters planned.

<Callout title="No runtime cost">
  Duck Gen produces `.d.ts` files only -- pure types that disappear at compile time. Duck Query is a thin wrapper over Axios that adds type inference without adding bundle weight.
</Callout>
